/*
    PlusCalc Interpreter
    Copyright (C) 2015 Ian Duncan

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
#include "pluscalc.h"
#include "pluscalcint.h"
#include <string.h>
#include <iostream>
#include <limits>
#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <sstream>
#include <fstream>
#include <readline/readline.h>
#include <readline/history.h>
#include <stdexcept>





std::string historypath;
std::vector<PCVariable> variables;
std::vector<PCIFunction> functions;
PCTrigMode tmode;





PCIFunction pci_create_function(std::string name, std::vector<PCCalcToken> tokens, std::vector<char> variable_names)
{
	PCIFunction func;

	func.name = name;
	func.tokens = tokens;
	func.variable_names = variable_names;

	return func;
}

int pci_get_function_id_by_name(std::string name)
{
	for(int i = 0; i < functions.size(); i++)
	{
		if(functions[i].name == name)
			return i;
	}

	throw variableerror;
	return 0;
}

long double pci_evaluate_function(PCIFunction function, std::string args)
{
	//Make a copy of the variables list
	std::vector<PCVariable> specvars = variables;

	//Delete variables that are function arguments
	for(int i = 0; i < function.variable_names.size(); i++)
	{
		for(int j = 0; j < specvars.size(); j++)
		{
			if(specvars[j].name == function.variable_names[i])
			{
				specvars.erase(specvars.begin()+j);
				break;
			}
		}
	}

	//Parse the arguments
	std::vector<std::string> arguments = PCStringSplit(args, ",", false);

	if(arguments.size() != function.variable_names.size())
		throw variableerror;

	for(int i = 0; i < arguments.size(); i++)
	{
		specvars.push_back(pc_create_variable(pc_parse_string(arguments[i], true), function.variable_names[i]));
	}

	//Evaluate
	return pc_evaluate_math_expression(function.tokens, specvars, tmode);
}

void exceptionresult(PCException err, bool exitonexception)
{
				int exitresult = 1;
				
				if(err == syntaxerror)
					std::cerr << "Error: Syntax Error while evaluating input." << std::endl;
				else if(err == lasttokenerror)
				{
					std::cerr << "Error: Last token was not a number." << std::endl;
					exitresult = 2;
				}
				else if(err == domainerror)
				{
					std::cerr << "Error: Domain error." << std::endl;
					exitresult = 3;
				}
				else if(err == operationerror)
				{
					std::cerr << "Error: No operations remain on stack." << std::endl;
					exitresult = 4;
				}
				else if(err == variableerror)
				{
					std::cerr << "Error: Variable error." << std::endl;
					exitresult = 8;
				}
				else
				{
					std::cerr << "Error: An unknown exception was caught." << std::endl;
					exitresult = 5;
				}
				
				if(exitonexception)
					exit(exitresult);
}

bool pci_save_vars_funcs_to_file(std::string fname)
{
	
		std::ofstream save(fname);

		if(save)
		{

		save << "# Save file generated by PlusCalc v1.99d\n\n";

		

		//Save all variables
		for(int i = 0; i < variables.size(); i++)
		{


			save << "set ";
			save << variables[i].name << " ";
			save << pc_tokens_to_string(variables[i].tokens) << std::endl;

			
		}

		//Save all functions
		for(int i = 0; i < functions.size(); i++)
		{
			save << "func ";
			save << functions[i].name << " ";

			//Write arguments
			for(int j = 0; j < functions[i].variable_names.size(); j++)
			{
				save << functions[i].variable_names[j];

				if(j != functions[i].variable_names.size() - 1)
					save << ",";
			}

			save << ";";
			save << pc_tokens_to_string(functions[i].tokens) << "\n";
		}
	}
	else
	{
		std::cout << "Error: Could not open file." << std::endl;
		return false;
	}

		save.close();
	



	

	
	

	return true;

}

long double pci_load_vars_funcs_from_file(std::string fname, long double ans,bool exitonexception)
{
	

	std::ifstream save(fname);
	long double newans = ans;

	if(save)
	{
		for( std::string line; std::getline( save, line ); )
		{
			
			

			if(!line.empty() && line[0] != '#')
			{
				
				newans = evaluateInput(line, newans, exitonexception);
			}
		}

	}
	else
	{
		std::cout << "Error: Could not open file." << std::endl;

		if(exitonexception)
			exit(9);
		
	}



	return newans;

}

int main(int argc, char **argv)
{
	
	historypath = getenv("HOME");
	historypath += "/.pluscalcint_history";
	tmode = deg;

	long double ans = 0;


	//Read from ~/.pluscalcintrc file if it exists

	std::string rcpath = getenv("HOME");
	rcpath += "/.pluscalcintrc";

	//std::cout << rcpath << std::endl;

	

	
	if(argc > 1 && std::string(argv[1]) != "-l" && std::string(argv[1]) != "-e")
	{
		if(pci_file_exists(rcpath))
		{
			evaluateInput("load " + rcpath, ans, false);
		}
		evaluateCmdInput(argc, argv);
	}
	else
	{
		
		
		read_history(historypath.c_str());
		
		
		
		

		if(argc > 2 && std::string(argv[1]) == "-e")
		{
			

			evaluateInput("load " + std::string(argv[2]), ans, true);
				
			exit(0);


		}
	
		std::cout << "PlusCalc Interpreter v1.99d" << std::endl << "Copyright (c) 2015 Ian Duncan" << std::endl << "This is free software with ABSOLUTELY NO WARRANTY.\nEnter 'license' for more information." <<  std::endl << "Enter 'quit' to exit and 'clear' to clear the history file (~/.pluscalcint_history)." << std::endl << std::endl;
		
		if(pci_file_exists(rcpath))
		{
			evaluateInput("load " + rcpath, ans, false);
		}
		if(tmode == deg)
			pci_report_trig_mode();

		std::cout << std::endl;

		if(argc > 2 && std::string(argv[1]) == "-l")
		{
			

			//Load files
			for(int i = 2; i < argc; i++)
			{
				ans = evaluateInput("load " + std::string(argv[i]), ans, false);
				
			}


		}

		

		while(1)
		{
			char *rawinput;
			char prompt[3] = "> ";
			//std::string input;

			//std::cout << "> ";
			//std::getline(std::cin, input);
			
			rawinput = readline(prompt);

			if(strlen(rawinput) == 0)
				;
			else
			{
			
				if(!rawinput || std::string(rawinput) == "quit")
					exit(0);
				
				add_history(rawinput);
				write_history(historypath.c_str());

				ans = evaluateInput(std::string(rawinput), ans, false);
				
				free(rawinput);
			}
			
			

		}
	}

	return 0;
}

void replaceAll(std::string& str, const std::string& from, const std::string& to) {
    if(from.empty())
        return;
    size_t start_pos = 0;
    while((start_pos = str.find(from, start_pos)) != std::string::npos) {
        str.replace(start_pos, from.length(), to);
        start_pos += to.length(); // In case 'to' contains 'from', like replacing 'x' with 'yx'
    }
}



long double evaluateInput(std::string input, long double ans, bool exitonexception, bool passexceptionson)
{
		
		std::cout.precision(std::numeric_limits<long double>::digits10 + 1);
		
		long double newans = 0;
		
		
		
		if(input == "quit")
			exit(0);
		else if(input == "license")
		{
		
		    std::cout << "PlusCalc Interpreter v1.99d" << std::endl;
    		std::cout << "Copyright (C) 2015 Ian Duncan" << std::endl << std::endl;

    		std::cout << "This program is free software: you can redistribute it and/or modify" << std::endl;
		    std::cout << "it under the terms of the GNU General Public License as published by" << std::endl;
		    std::cout << "the Free Software Foundation, either version 3 of the License, or" << std::endl;
		    std::cout << "(at your option) any later version." << std::endl << std::endl;

		    std::cout << "This program is distributed in the hope that it will be useful," << std::endl;
		    std::cout << "but WITHOUT ANY WARRANTY; without even the implied warranty of" << std::endl;
		    std::cout << "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the" << std::endl;
		    std::cout << "GNU General Public License for more details." << std::endl << std::endl;

		    std::cout << "You should have received a copy of the GNU General Public License" << std::endl;
		    std::cout << "along with this program.  If not, see <http://www.gnu.org/licenses/>." << std::endl << std::endl;
		}
		else if(input == "clear")
		{
			clear_history();
			if(history_truncate_file(historypath.c_str(), 0) != 0)
			{
				std::cout << "History clear NOT successful. Entries may remain in file." << std::endl;
				if(exitonexception)
					exit(7);
			}
			else
			{
				
				std::cout << "History clear successful." << std::endl;
			}
		}
		else
		{
			try
			{
				std::vector<std::string> inputvec;

				inputvec = PCStringSplit(input);

				//We need to set a variable
				if(inputvec[0] == "set" && inputvec.size() > 2)
				{

					char name = (inputvec[1])[0];

					//Remove variable entries with the same name
					for(int i = 0; i < variables.size(); i++)
					{
						if(variables[i].name == name)
						{
							variables.erase(variables.begin()+i);
							break;
						}
					}

					//Build the string to tokenize
					std::string varraw = "";

					for(int i = 2; i < inputvec.size(); i++)
					{
						varraw += inputvec[i] + " ";
					}

					replaceAll(varraw,"ans",std::to_string(ans));

					variables.push_back(pc_create_variable(pc_parse_string(varraw, true), name));


				}
				//We need to get user input to define a variable
				else if(inputvec[0] == "input" && inputvec.size() >= 2)
				{
					char name = (inputvec[1])[0];

					//Remove variable entries with the same name
					for(int i = 0; i < variables.size(); i++)
					{
						if(variables[i].name == name)
						{
							variables.erase(variables.begin()+i);
							break;
						}
					}

					std::string uinput;

					if(inputvec.size() == 2)
						std::cout << name << "? ";
					else
					{
						//Build the prompt
						std::string prompt = "";

						for(int i = 2; i < inputvec.size(); i++)
						{
							prompt += inputvec[i] + " ";
						}

						std::cout << prompt;
					}

					std::cin >> uinput;

					variables.push_back(pc_create_variable(pc_parse_string(uinput, true), name));


				}
				//We need to print a string and a newline
				else if(inputvec[0] == "print" && inputvec.size() > 1)
				{
						//Build the string
						std::string toprint = "";

						for(int i = 1; i < inputvec.size(); i++)
						{
							toprint += inputvec[i] + " ";
						}

						std::cout << toprint << std::endl;
				}
				//We need to print a string without a newline
				else if(inputvec[0] == "printr" && inputvec.size() > 1)
				{
						//Build the string
						std::string toprint = "";

						for(int i = 1; i < inputvec.size(); i++)
						{
							toprint += inputvec[i] + " ";
						}

						std::cout << toprint;
				}
				//We need to test if number is prime
				else if(inputvec[0] == "isprime" && inputvec.size() > 1)
				{
					std::string ip_full = "";

					//build the string
					for(int i = 1; i < inputvec.size(); i++)
					{
						ip_full += inputvec[i];

						if(i < (inputvec.size() - 1))
							ip_full += " ";
					}

					//disable output
					std::cout.setstate(std::ios_base::failbit);
					double to_test = evaluateInput(ip_full, ans, false, true);

					//enable output
					std::cout.clear();

					bool prime = pci_is_prime(to_test);

					if(prime)
					{
						newans = 1;
						std::cout << "Prime" << std::endl;
					}
					else
					{
						newans = 0;
						std::cout << "Not prime" << std::endl;
					}
				}					
				//We need to do synthetic division
				else if(inputvec[0] == "synthdiv" && inputvec.size() > 1)
				{
					
					std::string sd_full = "";
					
					//build the string to tokenize
					for(int i = 1; i < inputvec.size(); i++)
					{
						sd_full += inputvec[i];

						if(i < (inputvec.size() - 1))
							sd_full += " ";
					}

					std::vector<std::string> argsdef = PCStringSplit(sd_full, ";", false, true);

					if(argsdef.size() != 2)
						throw syntaxerror;

					//disable output
					std::cout.setstate(std::ios_base::failbit);
					double divisor = evaluateInput(PCStringEscapeRemove(argsdef[0]), ans, false, true);

					//enable output
					std::cout.clear();

					

					std::vector<std::string> coef_str = PCStringSplit(argsdef[1], ",", false);

					if(coef_str.size() < 3)
						throw syntaxerror;

					

					std::vector<double> coefficients;

					std::cout.setstate(std::ios_base::failbit);

					for(int i = 0; i < coef_str.size(); i++)
					{
						coefficients.push_back(evaluateInput(coef_str[i], ans, false, true));

					}

					std::cout.clear();

					std::vector<double> synthdiv_ans = pci_synthetic_div(coefficients, divisor);

					newans = synthdiv_ans[synthdiv_ans.size() - 1];

					for(int i = 0; i < synthdiv_ans.size(); i++)
						std::cout << synthdiv_ans[i] << "\t";

					std::cout << std::endl;
				}					
				//We need to define a function
				else if(inputvec[0] == "func" && inputvec.size () > 2)
				{
					std::string name = inputvec[1];

					//Remove function entries with the same name
					for(int i = 0; i < functions.size(); i++)
					{
						if(functions[i].name == name)
						{
							functions.erase(functions.begin()+i);
							break;
						}
					}

					//Build the string to tokenize
					std::string fargsdef = "";

					for(int i = 2; i < inputvec.size(); i++)
					{
						fargsdef += inputvec[i] + " ";
					}

					//Split the arguments and definition
					std::vector<std::string> argsdef = PCStringSplit(fargsdef, ";", false);

					if(argsdef.size() != 2)
						throw syntaxerror;

					std::vector<char> variable_names;

					//Parse the list of arguments
					std::vector<std::string> args = PCStringSplit(argsdef[0], ",", false);

					if(args.size() < 1)
						throw syntaxerror;

					for(int i = 0; i < args.size(); i++)
					{
						char argname = (args[i])[0];

						//Check for duplicate arguments
						for(int j = 0; j < variable_names.size(); j++)
						{
							if(variable_names[j] == argname)
								throw syntaxerror;
						}

						variable_names.push_back(argname);
					}

					std::string def = argsdef[1];
					replaceAll(def,"ans",std::to_string(ans));

					//Create the function and add it to the list
					functions.push_back(pci_create_function(name, pc_parse_string(def, true), variable_names));




				}
				//We need to execute a function
				else if(inputvec[0] == "call" && inputvec.size() > 2)
				{
					std::string name = inputvec[1];

					//Join the arguments together
					std::string args = "";

					for(int i = 2; i < inputvec.size(); i++)
					{
						args += inputvec[i] + " ";
					}

					newans = pci_evaluate_function(functions[pci_get_function_id_by_name(name)], args);

					if(fmod(newans, 1) == 0)
						std::cout << (long long)newans << std::endl;
					else
						std::cout <<  newans << std::endl;



				}
				//We need to generate a table of values
				else if(inputvec[0] == "tablegen" && inputvec.size() == 4)
				{
					std::string name = inputvec[1];

					int begin = atoi(inputvec[2].c_str());
					int end = atoi(inputvec[3].c_str());

					if(end < begin)
						throw syntaxerror;

					for(int i = begin; i <= end; i++)
					{
						std::stringstream ss;
						ss << i;

						newans = pci_evaluate_function(functions[pci_get_function_id_by_name(name)], ss.str());

						if((begin < 0 || end < 0) && i >= 0)
							std::cout << " " << i << "\t";
						else
							std::cout << i << "\t";

						if(fmod(newans, 1) == 0)
							if( newans >= 0)
								std::cout << " " << (long long)newans << std::endl;
							else
								std::cout << (long long)newans << std::endl;
						else
						{
							if( newans >= 0)
								std::cout <<  " " << newans << std::endl;
							else
								std::cout <<  newans << std::endl;
						}
					}
				}
				//We need to save and functions to a file
				else if(inputvec[0] == "save" && inputvec.size() == 2)
				{
					pci_save_vars_funcs_to_file(inputvec[1]);
				}
				//We need to load a file
				else if(inputvec[0] == "load" && inputvec.size() == 2)
				{
					newans = pci_load_vars_funcs_from_file(inputvec[1], ans);
				}
				//We need to set or display the trig mode
				else if(inputvec[0] == "tmode")
				{
					if(inputvec.size() == 2)
					{
						if(inputvec[1] == "deg")
						{
							tmode = deg;
						}
						else if(inputvec[1] == "rad")
						{
							tmode = rad;
						}
						else if(inputvec[1] == "grad")
						{
							tmode = grad;
						}
						else if(inputvec[1] == "turn")
						{
							tmode = turn;
						}
						else
						{
							std::cerr << "Info: Valid trigonometry modes are deg, rad, grad, or turn." << std::endl;
							throw syntaxerror;
						}
					}

					pci_report_trig_mode();
				}
				else
				{
					replaceAll(input,"ans",std::to_string(ans));
					newans = pc_evaluate_math_expression(input, variables, tmode);
					
					if(fmod(newans, 1) == 0)
						std::cout << (long long)newans << std::endl;
					else
						std::cout <<  newans << std::endl;
				}
			}
			catch(PCException err)
			{
				std::cout.clear();
				if(passexceptionson)
					throw err;
				else
					exceptionresult(err, exitonexception);
			}
			catch(std::exception &e)
			{
				std::cout.clear();
				if(passexceptionson)
					throw e;
				else
					std::cerr << "Error: Unknown error." << std::endl;
			}
			catch(...)
			{
				std::cout.clear();
				std::cerr << "Error: Unknown error." << std::endl;
			}
			
		}
		
		return newans;
}

void evaluateCmdInput(int argc, char **argv)
{
	std::string input;
	
	for(int i = 1; i < argc; i++)
	{
		input += std::string(argv[i]);
	}
	
	evaluateInput(input, 0, true);
}

void pci_report_trig_mode()
{
	switch(tmode)
	{
		case rad:
		{
			std::cout << "Trigonometry mode: radians" << std::endl;
			break;
		}
		case deg:
		{
			std::cout << "Trigonometry mode: degrees" << std::endl;
			break;
		}
		case grad:
		{
			std::cout << "Trigonometry mode: gradians" << std::endl;
			break;
		}
		case turn:
		{
			std::cout << "Trigonometry mode: turns" << std::endl;
			break;
		}
	}
}

bool pci_file_exists(std::string fname)
{
	FILE *file;
    if (file = fopen(fname.c_str(), "r"))
    {
        fclose(file);
        return 1;
    }
    return 0;
}

std::vector<double> pci_synthetic_div(std::vector<double> coefficients, double divisor)
{
	std::vector<double> row1 = coefficients;
        
	std::vector<double> row3(coefficients.size(),0);

	row3[0] = row1[0];

	for(int i = 1; i < row1.size(); i++)
	{
		double row2 = (row1[i-1] * divisor);

		row3[i] = row1[i] + row2;
	}

	return row3;
}

bool pci_is_prime(long double n)
{
	if(fmodl(n, 1) != 0)
		   return false;
	   
	if (n <= 3) {
		return n > 1;
	}

	if (fmodl(n,2) == 0 || fmodl(n,3) == 0) {
		return false;
	}
        long long sq=sqrtl(n); 
	for (long long i = 5; i<=sq; i += 6) {
		if (fmodl(n,i) == 0 || fmodl(n,(i + 2)) == 0) {
			return false;
		}
	}

	return true;
}
